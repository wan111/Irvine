//Dorothy2
//caption=JSON
//version=0.30
//hint=
//match=
//author=wan
//path=common
//end

/*
JSON形式の文字列をオブジェクトに変換する 失敗した場合はfalseを返す
text: オブジェクトに変換するJSON形式の文字列
*/
function parseJSON(source){
	if(typeof source != 'string' && nameOf(source) != 'String'){
		println('parse error>引数が文字列ではない');
		return false;
	}
	var Esc_char = {
		'"' : '"',  //quotation mark  U+0022
		'\' : '\',  //reverse solidus U+005C
		'/' : '/',  //solidus         U+002F
		'b' : "\b", //backspace       U+0008
		'f' : "\f", //form feed       U+000C
		'n' : String.fromCharCode(0x0A), //line feed U+000A
		'r' : "\r", //carriage return U+000D
		't' : "\t"  //tab             U+0009
	};
	var Str = new String(source);
	Str.index = -1;
	Str.end = Str.length - 1;
	//次の文字を取得する lenを指定した場合はlenの長さの文字列を取得
	//Str.indexは現在の位置
	Str.next = function(len){
		len = len || 1;
		var s = this.substr(this.index+1, len);
		this.index += len;
		if(this.index > this.end){
			throw 'parse error: index(' + this.index +  ')=>解析途中で文字列の終端に達した';
		}
		return s;
	};
	//次の文字を取得する 空白の場合スキップする
	Str.nextStr = function(){
		var r;
		while(true){
			switch(r = this.next()){
				case ' ':
				case Esc_char.t:
				case Esc_char.n:
				case Esc_char.r:
					continue;
			}
			break;
		}
		return r;
	};
	function err(e){
		throw 'parse error: index(' + Str.index +  ')=>' + e;
	}
	//オブジェクトを解析する
	//呼ばれた時のStr.indexは最初の{の位置
	function parseObj(){
		var obj = {};
		if(Str.nextStr() == '}') return obj;//空オブジェクト
		while(true){
			if(Str[Str.index] != '"') err('オブジェクトのメンバー名が文字列ではない');
			var key = parseStr();
			if(Str.nextStr() != ':') err('オブジェクトのメンバー名の後に:がない');
			Str.nextStr();
			obj[key] = parseValue();
			switch(Str.nextStr()){
				case ',':
					Str.nextStr();
					continue;
				case '}': return obj;
				default: err('オブジェクトの値が[,]で区切られていない');
			}
		}
	}
	//配列を解析する
	//呼ばれた時のStr.indexは最初の[の位置
	function parseArr(){
		var arr = [];
		if(Str.nextStr() == ']') return arr;//空配列
		while(true){
			arr.push(parseValue());
			switch(Str.nextStr()){
				case ',':
					Str.nextStr();
					continue;
				case ']': return arr;
				default: err('配列の値が[,]で区切られていない');
			}
		}
	}
	//文字列を解析
	//呼ばれた時のStr.indexは最初の"の位置
	function parseStr(){
		var r = s = '';
		while(s = Str.next()){
			if(s == '"') return r;
			if(s == '\'){
				s = Str.next();
				if(Esc_char.hasKey(s)){
					s = Esc_char[s];
				}else if(s == 'u'){
					//uの後が正しい文字コードかチェックするように 間違っていた場合はそのまま変換せず出力
					s = _unescape();
				}
			}
			r += s;
		}
		err('文字列が"で閉じられていない');
	}
	//数値を解析
	//呼ばれた時のStr.indexは数値の始まり[0-9\-]の位置
	function parseNumber(){
		/*
		number = [ minus ] int [ frac ] [ exp ]
		decimal-point = %x2E       ; .
		digit1-9 = %x31-39         ; 1-9
		e = %x65 / %x45            ; e E
		exp = e [ minus / plus ] 1*DIGIT
		frac = decimal-point 1*DIGIT
		int = zero / ( digit1-9 *DIGIT )
		minus = %x2D               ; -
		plus = %x2B                ; +
		zero = %x30                ; 0
		*/
		var start = Str.index,
		s = Str[start],
		p = e = false;
		
		if(s == '-') s = Str.next();
		if(!(s | 0 || s == '0')) err('数値ではない');
		
		while(true){
			while((s | 0 || s == '0') && (s = Str.next()));
			if(s == '.'){
				if(p || e) break;
				p = true;
				s = Str.next();
			}else if(s == 'e' || s == 'E'){
				if(e) break;
				e = true;
				s = Str.next();
				if(s == '+' || s == '-') s = Str.next();
			}else{
				--Str.index;
				s = Str[Str.index];
				if(!(s | 0 || s == '0')) break;//小数点,指数の次が数字ではない場合
				var r = Str.slice(start, Str.index+1);
				return parseFloat(r);
			}
		}
		err('数値ではない');
	}
	//オブジェクト・配列の値を解析する
	//呼ばれた時のStr.indexは値の最初の文字の位置
	function parseValue(){
		/*
		value = false / null / true / object / array / number / string
		false = %x66.61.6c.73.65   ; false
		null  = %x6e.75.6c.6c      ; null
		true  = %x74.72.75.65      ; true
		*/
		var s = Str[Str.index];
		switch(s){
			case '{': return parseObj();
			case '"': return parseStr();
			case '[': return parseArr();
			case 'f'://false
				if(Str.next(4) == 'alse') return false;
				break;
			case 't'://true
				if(Str.next(3) == 'rue') return true;
				break;
			case 'n'://null
				if(Str.next(3) == 'ull') return null;
				break;
			default://number or error
				if(s | 0 || s == '0' || s == '-') return parseNumber();
		}
		err('不正な値');
	}
	//rentanさんのUt8.dmsから拝借しました
	function _unescape(){
		// \uXXXX ... \u0000〜\uffff
		var r = Str[Str.index],
		s = Str.next(4);
		if (/^[0-9a-f]{4}/i.test (s)) {
			s = parseInt ('0x' + s);  // 0〜0xffff
			
			var m = s & 0xfc00;
			if (m == 0xd800) {
				// high surrogate
				var s2 = Str.next(6);  //  0〜0xffff
				s2 = /^\\u[0-9a-fA-F]{4}/.test (s2) ? parseInt ('0x' + s2.slice (2)) : 0;
				
				if ((s2 & 0xfc00) == 0xdc00) {
					r = fromUnicode (0x10000 + ((s & 0x03ff) << 10) + (s2 & 0x03ff));
				}
				else {
					Str.index -= 6;
					// high surrogate の直後が low surrogate ではない
					// または Unicode エスケープシーケンスではない
					r = '[U+' + s + ']';
				}
			}
			else if (m == 0xdc00) {
				// いきなり low surrogate がきた
				r = '[U+' + s + ']';
			}
			else {
				// 基本多言語面のコードポイント
				r = fromUnicode (s);
			}
		}else{
			Str.index -= 4;
		}
		return r;
	}
	function fromUnicode(u){
		if (u <= 0x7f) {
			return String.fromCharCode (u);
		}
		if (u <= 0x7ff) {
			var n1 = u >> 6;
			var n2 = u & 0x3f;
			return String.fromCharCode (n1 + 0xc0, n2 + 0x80);
		}
		if (u <= 0xffff) {
			var n1 = u >> 12;
			var n2 = (u >> 6) & 0x3f;
			var n3 = u & 0x3f;
			return String.fromCharCode (n1 + 0xe0, n2 + 0x80, n3 + 0x80);
		}
		if (u <= 0x1fffff) {
			var n1 = u >> 18;
			var n2 = (u >> 12) & 0x3f;
			var n3 = (u >> 6) & 0x3f;
			var n4 = u & 0x3f;
			return String.fromCharCode (n1 + 0xf0, n2 + 0x80, n3 + 0x80, n4 + 0x80);
		};

		return '[UTF-8 error]';
	}
	var r = false;
	try{
		switch(Str.nextStr()){
			case '{': r = parseObj();break;
			case '[': r = parseArr();break;
			default: err('JSON文字列ではない');
		}
		if(Str.index < Str.end){
			r = false;
			Str.index++;
			err(Str[Str.index-1] + 'の後に不明な文字がある');
		}
	}catch(e){
		println(e);
	}
	return r;
},
/*
オブジェクトをJSON文字列に変換する
obj: 文字列に変換するオブジェクト
esc: trueなら", \, /, \b, \f, \n, \r, \tをエスケープ文字に変換します
     ASCII範囲外の文字は \u[4桁の16進数] に変換する UTF-8以外の文字列を渡すと正常に変換できません
     デフォルトはfalse
indent: インデントに使用する文字 指定した場合は自動で改行します
key_quot: オブジェクトのキーを囲む文字("key":value) 2文字で指定してください デフォルトは("")  例. (「」)
str_quot: 文字列の値を囲む文字 文字列以外の数値等には使用しません 2文字で指定してください デフォルトは("")
colon: オブジェクト({key:value})のコロンを別の文字にしたい場合に指定
comma: オブジェクトと配列([0,1,2])の区切り文字のコンマを別の文字にしたい場合に指定
*/
function stringifyJSON(obj, esc, indent, key_quot, str_quot, colon, comma){
	var control_char = {
		0x0a: "\\n",
		0x0d: "\\r",
		0x0c: "\\f",
		0x09: "\\t",
		0x08: "\\b"
	};
	var toEscape = function(s){
		if(!s) return s;
		/*
		s = s.replace(/(\\*)([\\"\/])([nrftb]|)/g, function(m, a, b, c){
			return (a.length % 2 == 0) ? (b == "\\" ? (c ? m : a + "\\\\") : a + "\\" + b) : m;
		});
		*/
		s = s.replace(/[\/"\\]/g, '\\$0');
		s = s.replace(/[\n\r\f\t\b]/g, function(m){
			return control_char[m.charCodeAt(0)];
		});

		if(/^[\s -~]+$/.test(s)) return s;
		//s = s.toUTF8();

		//rentan氏のutf8.dmsから拝借
		var sb = new StringBuffer(s);
		var sb_len = sb.length;
		var len = 0;
		var result = '';
		var n1, n2, n3, n4;
		for(var i = 0; i < sb_len; i += len){
			n1 = sb.charCodeAt(i);
			if (n1 <= 0x7f) {
				len = 1;
				result += sb[i];
				continue;
			}
			else if (n1 <= 0xc1) {	// 0x80-0xc1 不正なコード
				len = 1;
				continue;
			}
			else if (n1 <= 0xdf) {
				len = 2;
				n1 = n1 & 0x1f;
				n2 = sb.charCodeAt (i + 1) & 0x3f;
				unicode = (n1 << 6) + n2;
			}
			else if (n1 <= 0xef) {
				len = 3;
				n1 = n1 & 0x0f;
				n2 = sb.charCodeAt (i + 1) & 0x3f;
				n3 = sb.charCodeAt (i + 2) & 0x3f;
				unicode = (n1 << 12) + (n2 << 6) + n3;
			}
			else if (n1 <= 0xf7) {
				len = 4;
				n1 = n1 & 0x07;
				n2 = sb.charCodeAt (i + 1) & 0x3f;
				n3 = sb.charCodeAt (i + 2) & 0x3f;
				n4 = sb.charCodeAt (i + 3) & 0x3f;
				unicode = (n1 << 18) + (n2 << 12) + (n3 << 6) + n4;
			}
			else {			// 0xf8-0xff 不正なコード
				len = 1;
				continue;
			}
			result += format('\u%.4x', parseInt(unicode));
		}
		return result;
	};
	var toStr = function(value, space){
		switch(typeof value){
			case 'string':
				var tmp = esc ? toEscape(value) : value;
				return s_quot[0] + tmp + s_quot[1];
			case 'number':
			case 'boolean':
				return value.toString();
			case 'null':
			case 'undefined':
				return 'null';
			case 'object':
				var isObj = false;
				switch(nameOf(value)){
					case 'Object': isObj = true;
					case 'IrvineUrlInfo':
					case 'IrvineItem':
					case 'IrvineFolderData':
					case 'IrvineOptionData':
						var s = [], sp = space + indent;
						var i;
						if(i = check(value)){
							for(var key in value){
								if(isObj || (typeof value[key] != 'undefined')) s.add(k_quot[0] + (esc ? toEscape(key) : key) + k_quot[1] + colon + toStr(value[key], sp));
							}
						}
						cache = cache.slice(0, i-1);
						sp = n + sp;
						return '{' + sp + s.join(comma + sp) + n + space + '}';
					case 'Array':
						var s = [], sp = space + indent;
						var i;
						if(i = check(value)){
							for(var i = 0; i < value.length; i++){
								s.add(toStr(value[i], sp));
							}
						}
						cache = cache.slice(0, i-1);
						sp = n + sp;
						return '[' + sp + s.join(comma + sp) + n + space + ']';
					case 'String':
					case 'Date':
						var tmp = esc ? toEscape(value) : value;
						return s_quot[0] + tmp + s_quot[1];
				}
		}
		if(typeof value.toString == 'function'){
			var tmp = esc ? toEscape(value.toString()) : value.toString();
			return s_quot[0] + tmp + s_quot[1];
		}
		return '{}';

	};
	var cache = [];
	var check = function(obj){
		for(var i in cache){
			if(cache[i] === obj) return false;
		}
		return cache.push(obj);
	};
	var n = '', 
	    k_quot = typeof key_quot.length != 'undefined' ? (key_quot.length == 2 ? [key_quot[0], key_quot[1]] : ['', '']) : ['"', '"'],
	    s_quot = typeof str_quot.length != 'undefined' ? (str_quot.length == 2 ? [str_quot[0], str_quot[1]] : ['', '']) : ['"', '"']; 
	esc = esc || false;
	colon = typeof colon == 'string' ? colon : ':';
	comma = typeof comma == 'string' ? comma : ',';

	if(typeof indent == 'string' || nameOf(indent) == 'String'){
		n = "\n";
	}else{
		indent = '';
	}
	return toStr(obj, '');
};
