//Dorothy2
//caption=JSON
//version=0.32
//hint=
//match=
//author=wan
//path=common
//end

/*
JSON文字列を解析する
parseJSON(source[, reviver]);
	引数
		source: 解析するJSON形式の文字列(object,array,value)
		reviver:
			省略可能。解析結果を変換する関数 プロパティ名とプロパティの値が引数して渡される thisはそのプロパティを含むオブジェクト
			プロパティの値を戻り値に置き換える nullかundefinedを返した場合そのプロパティを削除
			最もネストされたプロパティから順次呼び出され最後は空文字列と最上位の値になる
			sourceにvalueを指定した場合はプロパティ名は空プロパティの値はsource thisは{'', source}となる
	戻り値
		オブジェクトか配列か値[string,number,true or false, null]
		sourceに文字列ではなくboolean, number, nullを渡した場合はそのまま返す
		構文が間違っていた場合はfalse
*/
function parseJSON(source, reviver){
	var Esc_char = {
		'"' : '"',  //quotation mark  U+0022
		'\' : '\',  //reverse solidus U+005C
		'/' : '/',  //solidus         U+002F
		'b' : "\b", //backspace       U+0008
		'f' : "\f", //form feed       U+000C
		'n' : String.fromCharCode(0x0A), //line feed U+000A
		'r' : "\r", //carriage return U+000D
		't' : "\t"  //tab             U+0009
	};
	var Str = new String(source);
	Str.index = -1;
	Str.end = Str.length - 1;
	//次の文字を取得する lenを指定した場合はlenの長さの文字列を取得
	//Str.indexは現在の位置
	Str.next = function(len){
		len = len || 1;
		var s = this.substr(this.index+1, len);
		this.index += len;
		return s;//終端に達した場合は空文字
	};
	//次の文字を取得する 空白の場合スキップする
	Str.nextStr = function(){
		var r;
		while(true){
			switch(r = this.next()){
				case ' ':
				case Esc_char.t:
				case Esc_char.n:
				case Esc_char.r:
					continue;
			}
			break;
		}
		return r;
	};
	function err(e){
		throw 'parse error: index(' + Str.index +  ')=>' + e;
	}
	//オブジェクトを解析する
	//呼ばれた時のStr.indexは最初の{の位置
	function parseObj(){
		var obj = {}, s = Str.nextStr();
		if(s == '}') return obj;//空オブジェクト
		while(s){
			if(s != '"') err('オブジェクトのメンバー名が文字列ではない');
			var key = parseStr();
			if(Str.nextStr() != ':') err('オブジェクトのメンバー名の後に:がない');
			Str.nextStr();
			obj[key] = parseValue();
			switch(Str.nextStr()){
				case ',':
					s = Str.nextStr();
					continue;
				case '}': return obj;
				default: err('オブジェクトの値がコンマで区切られていない');
			}
		}
		err('オブジェクトが閉じていない');
	}
	//配列を解析する
	//呼ばれた時のStr.indexは最初の[の位置
	function parseArr(){
		var arr = [], s = Str.nextStr();
		if(s == ']') return arr;//空配列
		while(s){
			arr.push(parseValue());
			switch(Str.nextStr()){
				case ',':
					s = Str.nextStr();
					continue;
				case ']': return arr;
				default: err('配列の値がコンマで区切られていない');
			}
		}
		err('配列が閉じていない');
	}
	//文字列を解析
	//呼ばれた時のStr.indexは最初の"の位置
	function parseStr(){
		var r = '', s = Str.next();
		while(s){
			if(s == '"') return r;
			if(s == '\'){
				s = Str.next();
				if(Esc_char.hasKey(s)){
					s = Esc_char[s];
				}else if(s == 'u'){
					//uの後が正しい文字コードかチェックするように 間違っていた場合はエラーに
					s = _unescape();
					if(s == '') err('不正なUnicode エスケープシーケンス');
				}else{
					continue;
				}
			}
			r += s;
			s = Str.next();
		}
		err('文字列が"で閉じられていない');
	}
	//数値を解析
	//呼ばれた時のStr.indexは数値の始まり[0-9\-]の位置
	function parseNumber(){
		/*
		number = [ minus ] int [ frac ] [ exp ]
		decimal-point = %x2E       ; .
		digit1-9 = %x31-39         ; 1-9
		e = %x65 / %x45            ; e E
		exp = e [ minus / plus ] 1*DIGIT
		frac = decimal-point 1*DIGIT
		int = zero / ( digit1-9 *DIGIT )
		minus = %x2D               ; -
		plus = %x2B                ; +
		zero = %x30                ; 0
		*/
		var start = Str.index,
		s = Str[start],
		p = e = isZero = false;
		
		if(s == '-') s = Str.next();
		if(s == '0') isZero = true;
		else if(!(s | 0)) err('数値ではない');
		//err[00, -00, 0123, 00.0, -00.0, 00e+1, 0123e1, 0123.0, 0123.1e1] ok[0e+1, 0e000, 0.000]
		//先頭から複数連続した0は禁止する
		//0の直後に指数と小数がある場合を除いて0から始まる数値は禁止する
		//00, 0[1-9] になった時点でエラー
		while(s){
			if(isZero){
				s = Str.next();
				if(s | 0 || s == '0') err('不正な数値 0が先行している');
				isZero = false;
			}
			while((s | 0 || s == '0') && (s = Str.next()));
			if(s == '.'){
				if(p || e) break;//.が2回又はeの後に.がある
				p = true;
				s = Str.next();
			}else if(s == 'e' || s == 'E'){
				if(e) break;//eが2回ある
				e = true;
				s = Str.next();
				if(s == '+' || s == '-') s = Str.next();
			}else{
				--Str.index;
				s = Str[Str.index];
				if(!(s | 0 || s == '0')) break;//小数点,指数の次が数字ではない場合
				var r = Str.slice(start, Str.index+1);
				return parseFloat(r);
			}
		}
		err('不正な数値');
	}
	//オブジェクト・配列の値を解析する
	//呼ばれた時のStr.indexは値の最初の文字の位置
	function parseValue(){
		/*
		value = false / null / true / object / array / number / string
		false = %x66.61.6c.73.65   ; false
		null  = %x6e.75.6c.6c      ; null
		true  = %x74.72.75.65      ; true
		*/
		var s = Str[Str.index];
		switch(s){
			case '{': return parseObj();
			case '"': return parseStr();
			case '[': return parseArr();
			case 'f'://false
				if(Str.next(4) == 'alse') return false;
				break;
			case 't'://true
				if(Str.next(3) == 'rue') return true;
				break;
			case 'n'://null
				if(Str.next(3) == 'ull') return null;
				break;
			default://number or error
				if(s | 0 || s == '0' || s == '-') return parseNumber();
		}
		err('不正な値');
	}
	//rentanさんのUt8.dmsから拝借しました
	function _unescape(){
		// \uXXXX ... \u0000〜\uffff
		var r = '',
		s = Str.next(4);
		if (/^[0-9a-f]{4}/i.test (s)) {
			s = parseInt ('0x' + s);  // 0〜0xffff
			
			var m = s & 0xfc00;
			if (m == 0xd800) {
				// high surrogate
				var s2 = Str.next(6);  //  0〜0xffff
				s2 = /^\\u[0-9a-fA-F]{4}/.test (s2) ? parseInt ('0x' + s2.slice (2)) : 0;
				
				if ((s2 & 0xfc00) == 0xdc00) {
					r = fromUnicode (0x10000 + ((s & 0x03ff) << 10) + (s2 & 0x03ff));
				}
				else {
					Str.index -= 6;
					// high surrogate の直後が low surrogate ではない
					// または Unicode エスケープシーケンスではない
					r = '[U+' + s + ']';
				}
			}
			else if (m == 0xdc00) {
				// いきなり low surrogate がきた
				r = '[U+' + s + ']';
			}
			else {
				// 基本多言語面のコードポイント
				r = fromUnicode (s);
			}
		}else{
			Str.index -= 4;
		}
		return r;
	}
	function fromUnicode(u){
		if (u <= 0x7f) {
			return String.fromCharCode (u);
		}
		if (u <= 0x7ff) {
			var n1 = u >> 6;
			var n2 = u & 0x3f;
			return String.fromCharCode (n1 + 0xc0, n2 + 0x80);
		}
		if (u <= 0xffff) {
			var n1 = u >> 12;
			var n2 = (u >> 6) & 0x3f;
			var n3 = u & 0x3f;
			return String.fromCharCode (n1 + 0xe0, n2 + 0x80, n3 + 0x80);
		}
		if (u <= 0x1fffff) {
			var n1 = u >> 18;
			var n2 = (u >> 12) & 0x3f;
			var n3 = (u >> 6) & 0x3f;
			var n4 = u & 0x3f;
			return String.fromCharCode (n1 + 0xf0, n2 + 0x80, n3 + 0x80, n4 + 0x80);
		};

		return '[UTF-8 error]';
	}
	function walk(obj, key){
		var value = obj[key];
		if(typeof value == 'object'){
			for(var i in value){
				value[i] = walk(value, i);
				if(isUndefined(value[i]) || isNull(value[i])){
					value.removeKey(i);
				}
			}
		}
		return reviver.call(obj, key, value);
	}
	var r = false;
	try{
		switch(typeof source){
			case 'string': break;
			case 'number':
			case 'null':
			case 'boolean': return source;
			case 'object':
				switch(nameOf(source)){
					case 'String': break;
					case 'Number': return source;
				}
			case 'undefined':
			default:  err('引数が不正');
		}
		Str.nextStr();
		r = parseValue();
		if(Str.nextStr()){ //残りが空白のみなら空文字になる
			r = false;
			err('不正な文字列');
		}
	}catch(e){
		println(e);
		return r;
	}
	//reviver(key, value) thisはkeyを持つオブジェクト
	return typeof reviver == 'function' ? walk({'': r}, '') : r;
},
/*
オブジェクトをJSON文字列に変換する
obj: 文字列に変換するオブジェクト
esc: trueなら", \, /, \b, \f, \n, \r, \tをエスケープ文字に変換します
     ASCII範囲外の文字は \u[4桁の16進数] に変換する UTF-8以外の文字列を渡すと正常に変換できません
     デフォルトはfalse
indent: インデントに使用する文字 指定した場合は自動で改行します
key_quot: オブジェクトのキーを囲む文字("key":value) 2文字で指定してください デフォルトは("")  例. (「」)
str_quot: 文字列の値を囲む文字 文字列以外の数値等には使用しません 2文字で指定してください デフォルトは("")
colon: オブジェクト({key:value})のコロンを別の文字にしたい場合に指定
comma: オブジェクトと配列([0,1,2])の区切り文字のコンマを別の文字にしたい場合に指定
*/
function stringifyJSON(obj, esc, indent, key_quot, str_quot, colon, comma){
	var control_char = {
		0x0a: "\\n",
		0x0d: "\\r",
		0x0c: "\\f",
		0x09: "\\t",
		0x08: "\\b"
	};
	var toEscape = function(s){
		if(!s) return s;
		/*
		s = s.replace(/(\\*)([\\"\/])([nrftb]|)/g, function(m, a, b, c){
			return (a.length % 2 == 0) ? (b == "\\" ? (c ? m : a + "\\\\") : a + "\\" + b) : m;
		});
		*/
		s = s.replace(/[\/"\\]/g, '\\$0');
		s = s.replace(/[\n\r\f\t\b]/g, function(m){
			return control_char[m.charCodeAt(0)];
		});

		if(/^[\s -~]+$/.test(s)) return s;
		//s = s.toUTF8();

		//rentan氏のutf8.dmsから拝借
		var sb = new StringBuffer(s);
		var sb_len = sb.length;
		var len = 0;
		var result = '';
		var n1, n2, n3, n4;
		for(var i = 0; i < sb_len; i += len){
			n1 = sb.charCodeAt(i);
			if (n1 <= 0x7f) {
				len = 1;
				result += sb[i];
				continue;
			}
			else if (n1 <= 0xc1) {	// 0x80-0xc1 不正なコード
				len = 1;
				continue;
			}
			else if (n1 <= 0xdf) {
				len = 2;
				n1 = n1 & 0x1f;
				n2 = sb.charCodeAt (i + 1) & 0x3f;
				unicode = (n1 << 6) + n2;
			}
			else if (n1 <= 0xef) {
				len = 3;
				n1 = n1 & 0x0f;
				n2 = sb.charCodeAt (i + 1) & 0x3f;
				n3 = sb.charCodeAt (i + 2) & 0x3f;
				unicode = (n1 << 12) + (n2 << 6) + n3;
			}
			else if (n1 <= 0xf7) {
				len = 4;
				n1 = n1 & 0x07;
				n2 = sb.charCodeAt (i + 1) & 0x3f;
				n3 = sb.charCodeAt (i + 2) & 0x3f;
				n4 = sb.charCodeAt (i + 3) & 0x3f;
				unicode = (n1 << 18) + (n2 << 12) + (n3 << 6) + n4;
			}
			else {			// 0xf8-0xff 不正なコード
				len = 1;
				continue;
			}
			result += format('\u%.4x', parseInt(unicode));
		}
		return result;
	};
	var toStr = function(value, space){
		switch(typeof value){
			case 'string':
				var tmp = esc ? toEscape(value) : value;
				return s_quot[0] + tmp + s_quot[1];
			case 'number':
			case 'boolean':
				return value.toString();
			case 'null':
			case 'undefined':
				return 'null';
			case 'object':
				var isObj = false;
				switch(nameOf(value)){
					case 'Object': isObj = true;
					case 'IrvineUrlInfo':
					case 'IrvineItem':
					case 'IrvineFolderData':
					case 'IrvineOptionData':
						var s = [], sp = space + indent;
						var i;
						if(i = check(value)){
							for(var key in value){
								if(isObj || (typeof value[key] != 'undefined')) s.add(k_quot[0] + (esc ? toEscape(key) : key) + k_quot[1] + colon + toStr(value[key], sp));
							}
						}
						cache = cache.slice(0, i-1);
						sp = n + sp;
						return '{' + sp + s.join(comma + sp) + n + space + '}';
					case 'Array':
						var s = [], sp = space + indent;
						var i;
						if(i = check(value)){
							for(var i = 0; i < value.length; i++){
								s.add(toStr(value[i], sp));
							}
						}
						cache = cache.slice(0, i-1);
						sp = n + sp;
						return '[' + sp + s.join(comma + sp) + n + space + ']';
					case 'String':
					case 'Date':
						var tmp = esc ? toEscape(value) : value;
						return s_quot[0] + tmp + s_quot[1];
				}
		}
		if(typeof value.toString == 'function'){
			var tmp = esc ? toEscape(value.toString()) : value.toString();
			return s_quot[0] + tmp + s_quot[1];
		}
		return '{}';

	};
	var cache = [];
	var check = function(obj){
		for(var i in cache){
			if(cache[i] === obj) return false;
		}
		return cache.push(obj);
	};
	var n = '', 
	    k_quot = typeof key_quot.length != 'undefined' ? (key_quot.length == 2 ? [key_quot[0], key_quot[1]] : ['', '']) : ['"', '"'],
	    s_quot = typeof str_quot.length != 'undefined' ? (str_quot.length == 2 ? [str_quot[0], str_quot[1]] : ['', '']) : ['"', '"']; 
	esc = esc || false;
	colon = typeof colon == 'string' ? colon : ':';
	comma = typeof comma == 'string' ? comma : ',';

	if(typeof indent == 'string' || nameOf(indent) == 'String'){
		n = "\n";
	}else{
		indent = '';
	}
	return toStr(obj, '');
};
