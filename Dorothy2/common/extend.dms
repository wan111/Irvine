//Dorothy2
//caption=extend
//version=0.5
//hint=
//match=
//author=wan
//path=common
//end
function extend(/*deep, dest, source*/){
	function _extend(deep, dest, src){
		for(var key in src){
			if(deep && typeof src[key] == 'object'){
				if(circular.check(src[key])){
					switch(nameOf(src[key])){
						case 'Object':
							dest[key] = typeof dest[key] != 'undefined' && nameOf(dest[key]) == 'Object' ? dest[key] : {};
							circular.cache.push([dest[key], src[key]]);
							dest[key] = _extend(deep, dest[key], src[key]);
							continue;
						case 'Array':
							dest[key] = typeof dest[key] != 'undefined' && nameOf(dest[key]) == 'Array' ? dest[key] : [];
							circular.cache.push([dest[key], src[key]]);
							dest[key] = _extend(deep, dest[key], src[key]);
							continue;
						case 'Number':
							dest[key] = new Number(src[key].toString());
							break;
						case 'String':
							dest[key] = new String(src[key].toString());
							continue;
						case 'Boolean':
							dest[key] = new Boolean(src[key].toString());
							break;
						case 'RegExp':
							var reg = new RegExp(src[key].source);
							reg.ignoreCase= src[key].ignoreCase;
							reg.global= src[key].global;
							reg.multiline= src[key].multiline;
							dest[key] = reg;
							break;
						case 'Date':
							dest[key] = new Date(src[key].getTime());
							break;
						case 'URL':
							dest[key] = new URL(src[key].url);
							break;
						case 'Cookie':
							var cookie = new Cookie;
							cookie.parse(src[key].toString());
							dest[key] = cookie;
							break;
						case 'StringList':
							var sl = new Strings(src[key].text);
							sl.sorted = src[key].sorted;
							sl.caseSensitive = src[key].caseSensitive;
							sl.duplicates = src[key].duplicates;
							dest[key] = sl;
							break;
						case 'StringBuffer':
							dest[key] = new StringBuffer(src[key].text);
							continue;
						default:
							dest[key] = src[key];
							break;
					}
					circular.cache.push([dest[key], src[key]]);
				}else{
					dest[key] = circular.obj;
				}
			}else{
				dest[key] = src[key];
			}
		}
		//function型のメンバ 参照渡し
		if(nameOf(src) == 'Object'){
			var methods = src.getMethods(), key;
			for(var i = 0; i < methods.length; i++){
				key = methods[i];
				if(!Object.hasKey(key)) dest[key] = src[key];
			}
		}
		return dest;
	}
	//循環参照,重複している参照渡しの確認
	var circular = {
		cache: [],
		obj: {},
		check: function(dest, src){
			for(var i in cache){
				if(cache[i][1] === src){
					this.obj = cache[i][0];
					return false;
				}
			}
			return true;
		}
	};

	var deep = false, destination, source, len = arguments.length, i = 1;
	if(typeof arguments[0] == 'boolean'){
		deep = arguments[0];
		i++;
	}

	if(len == i){
		destination = this;
		i--;
	}else{
		destination = arguments[i-1];
		if(typeof destination != 'object') destination = {};
	}
	var sourceName;
	for(; i < len; i++){
		source = arguments[i];
		sourceName = nameOf(source);
		if((sourceName == 'Object' || sourceName == 'Array')){
			if(destination == source) continue;
			circular.check(destination, source);
			destination = _extend(deep, destination, source);
		}
	}
	return destination;
},
//型が同じ場合のみ上書き
function extend2(/*deep, dest, source*/){
	function _extend(deep, dest, src){
		var destType, destName, srcType, srcName;
		for(var key in src){
			destType = typeof dest[key];
			srcType = typeof src[key];
			srcName = nameOf(src[key]);
			destName = null;
			if(destType != 'undefined'){
				destName = nameOf(dest[key]);
				//型が同一か確認
				if(!(destType == srcType && destName == srcName)){
					println('型不一致>' + key);
					if(destType != 'object' && srcType == 'object'){
						//オブジェクト->プリミティブ型
						switch(destType){
							case 'string':
								if(srcName == 'String') dest[key] = src[key].valueOf();
								break;
							case 'number':
								if(srcName == 'Number') dest[key] = src[key].valueOf();
								break;
							case 'boolean':
								if(srcName == 'Boolean') dest[key] = src[key].valueOf();
								break;
						}
					}else if(destType == 'object' && srcType != 'object'){
						//プリミティブ型->オブジェクト
						switch(srcType){
							case 'string':
								if(destName == 'String') dest[key] = new String(src[key].toString());
								break;
							case 'number':
								if(destName == 'Number') dest[key] = new Number(src[key].toString());
								break;
							case 'boolean':
								if(destName == 'Boolean') dest[key] = new Boolean(src[key].toString());
								break;
						}
					}
					continue;
				}
			}

			if(deep && srcType == 'object'){
				if(circular.check(src[key])){
					switch(srcName){
						case 'Object':
							dest[key] = destName == 'Object' ? dest[key] : {};
							circular.cache.push([dest[key], src[key]]);
							dest[key] = _extend(deep, dest[key], src[key]);
							continue;
						case 'Array':
							dest[key] = destName == 'Array' ? dest[key] : [];
							circular.cache.push([dest[key], src[key]]);
							dest[key] = _extend(deep, dest[key], src[key]);
							continue;
						case 'Number':
							dest[key] = new Number(src[key].toString());
							break;
						case 'String':
							dest[key] = new String(src[key].toString());
							continue;
						case 'Boolean':
							dest[key] = new Boolean(src[key].toString());
							break;
						case 'RegExp':
							var reg = new RegExp(src[key].source);
							reg.ignoreCase= src[key].ignoreCase;
							reg.global= src[key].global;
							reg.multiline= src[key].multiline;
							dest[key] = reg;
							break;
						case 'Date':
							dest[key] = new Date(src[key].getTime());
							break;
						case 'URL':
							dest[key] = new URL(src[key].url);
							break;
						case 'Cookie':
							var cookie = new Cookie;
							cookie.parse(src[key].toString());
							dest[key] = cookie;
							break;
						case 'StringList':
							var sl = new Strings(src[key].text);
							sl.sorted = src[key].sorted;
							sl.caseSensitive = src[key].caseSensitive;
							sl.duplicates = src[key].duplicates;
							dest[key] = sl;
							break;
						case 'StringBuffer':
							dest[key] = new StringBuffer(src[key].text);
							continue;
						default:
							dest[key] = src[key];
							break;
					}
					circular.cache.push([dest[key], src[key]]);
				}else{
					dest[key] = circular.obj;
				}
			}else{
				dest[key] = src[key];
			}
		}
		//function型のメンバ 参照渡し
		if(nameOf(src) == 'Object'){
			var methods = src.getMethods(), key;
			for(var i = 0; i < methods.length; i++){
				destType = typeof dest[key];
				key = methods[i];
				if(!Object.hasKey(key) && (destType == 'function' || destType == 'undefined')) dest[key] = src[key];
			}
		}
		return dest;
	}
	//循環参照,重複している参照渡しの確認
	var circular = {
		cache: [],
		obj: {},
		check: function(src){
			for(var i in cache){
				if(cache[i][1] === src){
					this.obj = cache[i][0];
					return false;
				}
			}
			return true;
		}
	};

	var deep = false, destination, source, len = arguments.length, i = 1;
	if(typeof arguments[0] == 'boolean'){
		deep = arguments[0];
		i++;
	}

	if(len == i){
		destination = this;
		i--;
	}else{
		destination = arguments[i-1];
		if(typeof destination != 'object') destination = {};
	}
	var destinationName = nameOf(destination);
	var sourceName;
	for(; i < len; i++){
		source = arguments[i];
		sourceName = nameOf(source);
		if((sourceName == 'Object' || sourceName == 'Array') && destinationName == sourceName){
			if(destination == source) continue;
			circular.check(destination, source);
			destination = _extend(deep, destination, source);
		}
	}
	return destination;
},
Object.prototype.extend = extend;