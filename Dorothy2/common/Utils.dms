//Dorothy2
//caption=Utils
//version=1.5
//hint=
//match=
//author=wan
//path=common
//end

/**
 * @license
 * Copyright (C) 2015,2016 wan <thewanwan111@gmail.com>
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 * 
 */


(function(){
	/**
	 * ユーティリティ関数群  
	 * Utilsオブジェクト
	 * @namespace
	 */
	Utils = Global.Utils = typeof Utils == 'object' ? Utils : {};

	/**
	 * @const
	 * @type {undefined}
	 */
	Utils.UNDEFINED = (function(){})();


	/**
	 * エラーメッセージを整形して返します
	 * @param {string} message エラーメッセージ
	 * @param {string} [fileName=Dorothy.matchFile+'.dms'] ファイル名
	 * @param {string|number} [line=''] エラー発生箇所
	 * @param {string} [name='Error'] エラー名
	 * @return {String} 整形した文字列のStringオブジェクト 各引数をプロパティに追加
	 */
	Utils.error = function(message, fileName, line, name){
		var str = new String(message);
		str.message = str.text;
		str.fileName = fileName ? Utils.toStr(fileName) : Dorothy.matchFile + '.dms';
		str.line = line ? Utils.toStr(line) : '';
		str.name = name ? Utils.toStr(name) : 'Error';
		str.text = format('%s: %s %s: %s', str.name, str.fileName, str.line, str.message);

		return str;
	};

	/**
	 * エラーメッセージを整形してalertで表示します
	 * @param {string} message エラーメッセージ
	 * @param {string} [fileName=Dorothy.matchFile+'.dms'] ファイル名
	 * @param {string|number} [line=''] エラー発生箇所
	 * @param {string} [name='Error'] エラー名
	 * @return {String} 整形した文字列のStringオブジェクト 各引数をプロパティに追加
	 */
	Utils.showError = function(message, fileName, line, name){
		var e = Utils.error(message, fileName, line, name);
		alert(e);
		return e;
	};

	/** 
	 * 文字列として扱えるか判定します string String StringBufferならばtrue
	 * @param {*} v
	 * @return {boolean}
	 */
	Utils.isStr = function(v){
		return typeof v == 'string' || String === v || StringBuffer === v;
	};

	/**
	 * 文字列に変換
	 * @param {*} v
	 * @return {string}
	 */
	Utils.toStr = function(v){
		return typeof v.toString == 'function' ? v.toString() : new String(v).toString();
	};

	/**
	 * 数値に変換 数値に変換できないものはNaNを返します。
	 * @template T
	 * @param {*} v
	 * @param {T=} def 数値に変換できない場合に返す値
	 * @return {number|T}
	 */
	Utils.toNumber = function(v, def){
		return typeof v === 'number' ? v : isNull(v) ? 0 : isFinite(v) ? parseFloat(v) : arguments.length > 1 ? def : NaN;
	};

	/**
	 * 整数値に変換
	 * @param {*} v
	 * @return {number}
	 */
	Utils.toInteger = function (v){
		return v > 0 ? Math.floor(v) : Math.ceil(v);
	};

	/**
	 * オブジェクトをプリミティブ値に変換
	 * @param {*} v
	 * @return {string|number|boolean|null|undefined}
	 */
	Utils.objToPrimitive = function(v){
		var r = v,
			type = typeof v;
		if(type == 'object' || type == 'function'){
			if(nameOf(v) == 'Date'){
				r = v.toString();
			}else if(typeof v.valueOf == 'function'){
				r = v.valueOf();
				if((type = typeof r) == 'object' || type == 'function'){
					r = Utils.toStr(r);
				}
			}else{
				r = Utils.toStr(v);
			}
		}
		return r;
	};

	/**
	 * 文字列をプリミティブ値に変換
	 * 例: "true" -> true
	 * @param {*} s
	 * @return {string|number|boolean|null|undefined}
	 */
	Utils.strToPrimitive = function(s){
		var r = s = typeof s == 'object' ? Utils.objToPrimitive(s) : s;

		if(/^\s*(true|false|null|NaN|undefined|-?\d+(\.\d+)?([eE][+\-]?\d+)?|0[xX][\da-fA-F]+)\s*$/.test(s)){
			s = RegExp.$1;
			switch(s){
				case 'true':
				case 'false':
					r = s == 'true';
					break;
				case 'null':
					r = null;
					break;
				case 'NaN':
					r = NaN;
					break;
				case 'undefined':
					r = Utils.UNDEFINED;
					break;
				default:
					r = parseFloat(s);
			}
		}
		return r;
	};

	/**
	 * 渡された値からパスを取り出します
	 * @param {*} s
	 * @return {string} パス
	 */
	Utils.extractPath = function(s){
		return /^(.*[\\\/])/.test(s) ? RegExp.$1 : '';
	};

	/**
	 * 渡された値からファイル名を取り出します
	 * @param {*} s
	 * @return {string} ファイル名
	 */
	Utils.extractName = function(s){
		s = Utils.toStr(s);
		if(s.indexOf("\\") != -1){
			s = /^(.*\\)?(.+)/.test(s) ? RegExp.$2 : '';
		}else if(s.indexOf('/') != -1){
			s = /^(.*\/)?([^\/#?]+)/.test(s) ? RegExp.$2 : '';
		}else{
			s = s.replace(/\?.*$/, '');
		}
		return s;
	};

	/**
	 * 渡された値から拡張子を取り出します
	 * @param {*} s
	 * @return {string} 拡張子
	 */
	Utils.extractExt = function(s){
		return /\.[^.]+$/.test(Utils.extractName(s)) ? RegExp.$0 : '';
	};

	/**
	 * 渡された文字列から 置換変数(%〜%) を置換して整形します  
	 * mapのプロパティと同名の置換変数をその値で置き換えます mapに存在しない名前の置換変数は削除されます
	 * @param {string} s
	 * @param {Object=} map 置き換えに使用されるオブジェクト
	 * @return {string} 整形した文字列
	 */
	Utils.formatTemplate = function(s, map){
		s = Utils.toStr(s);
		map = map || {};
		function rep(a, key){
			return key == '' ? '%' : Utils.getObject(key, map, '');
		}
		return s.replace(/%(.*?)%/g, rep);
	};

	/**
	 * .call()の代替 関数のモードを変更せずに呼び出します。 戻り値で渡される関数が内部で元とは別の関数として扱われるのを利用しています
	 * @param {Function} fn 呼び出す関数
	 * @param {*} selfObj 関数fnの内部でthisとして使用される値
	 * @param {...*} var_args 関数fnに渡される引数
	 * @return {*} 関数fnの返り値
	 */
	Utils.call = function(fn, selfObj, var_args){
		if(typeof fn != 'function'){
			throw Utils.error('第一引数がfunctionではない', 'Utils.dms', '.call');
		}
		/*
		var len = arguments.length,
			args = [],
			p = [];

		for(var i = 2; i < len; i++){
			args.push(arguments[i]);
			p.push('args[' + (i -2) + ']');
		}

		var f = function(){
			var tmp = eval('function(){return fn(' + p.join(',') + ');}');
			return tmp();
		};

		return f.call(selfObj);
		*/
		var f = (function(f){return f;})(fn);
		return f.apply(selfObj, arguments.slice(2));
	};

	/**
	 * .apply()の代替 関数のモードを変更せずに呼び出します
	 * @param {Function} fn 呼び出す関数
	 * @param {*} selfObj 関数fnの内部でthisとして使用されるオブジェクト
	 * @param {?Array} argsArray 関数fnに渡される引数
	 * @return {*} 関数fnの返り値
	 */
	Utils.apply = function(fn, selfObj, argsArray){
		if(typeof fn != 'function'){
			throw Utils.error('第一引数がfunctionではない', 'Utils.dms', '.apply');
		}
		if(nameOf(argsArray) != 'Array' && !isNull(argsArray) && !isUndefined(argsArray)){
			throw Utils.error('第三引数がArrayではない', 'Utils.dms', '.apply');
		}
		/*
		var args = argsArray || [],
			len = args.length,
			p = [];

		for(var i = 0; i < len; i++) p.push('args[' + i + ']');

		var f = function(){
			var tmp = eval('function(){return fn(' + p.join(',') + ');}');
			return tmp();
		};

		return f.call(selfObj);
		*/
		var f = (function(f){return f;})(fn);
		return f.apply(selfObj, (argsArray || []));
	};

	/**
	 * objがkeyを持っているか
	 * @param {object} obj
	 * @param {string} key
	 * @return {boolean}
	 */
	Utils.has = function(obj, key){
		var r = true;
		if(nameOf(obj) == 'Array' && isFinite(key)){
			r = obj.length > key;
		}else{
			try{
				obj[key];
			}catch(e){
				r = false;
			}
		}
		return r;
	};

	/**
	 * 指定した完全修飾名のオブジェクトを取得します objを指定した場合はobjのプロパティから取得します
	 * @function
	 * @param {string} name 完全修飾名 例: Global.Utils.UNDEFINED 等
	 * @param {*=} obj このオブジェクを対象とします 省略した場合グローバルスコープとGlobalオブジェクトを対象とします
	 * @param {*=} def 見つからなかった場合に返す値
	 * @return {*}
	 */
	Utils.getObject = (function(){
		function _getObjFromGlobal(name){
			return eval([
			'(function(){',
			'  try{',
			'    return /^[_$a-zA-Z][a-zA-Z0-9]*$/.test("' + name + '") && !/^arguments/.test("' + name + '") ? ' + name + ': Global["' + name + '"];',
			'  }catch(e){}',
			'})()'
			].join("\n"));
		}
		return function(name, obj, def){
			var key,
				keys = isNull(name) || isUndefined(name) ? [] : Utils.toStr(name).split(/\./),
				r = obj || _getObjFromGlobal(key = keys.shift());
			if(isUndefined(r)) r = def;
			while(!isUndefined(key = keys.shift())){
				try{
					if(key == 'prototype') r = r.prototype;
					else r = r[key];
				}catch(e){
					r = def;
					break;
				}
			}
			return r;
		};
	})();

	/**
	 * オブジェクトの全てのプロパティ名を配列で返します。
	 * @param {*} obj オブジェクト
	 * @return {Array<string>}
	 */
	Utils.keys = function(obj){
		var key, keys,
			r = [],
			o = {},
			defaultMethods = /^(getEvents|getProperties|hasOwnProperty|getKeys|hasKey|valueOf|removeKey|toString|getMethods|constructor)$/,
			type = typeof obj,
			isObj = type == 'object',
			name = isObj && nameOf(obj),
			isPlainObject = name == 'Object',
			isArray = name == 'Array',
			isStr = type == 'string' || obj === String || obj === StringBuffer;

		if(isArray || isStr){
			for(var i = 0; i < obj.length; i++) r.push(i + '');
		}else if(isObj){
			if(typeof obj.getKeys == 'function'){
				keys = obj.getKeys();
				for(var i = 0; i < keys.length; i++){
					key = keys[i];
					if(isPlainObject ? typeof o[key] == 'undefined' : !defaultMethods.test(key)) r.push(key);
				}
			}
			//folderdata, prototypeはgetKeysでは取得出来ない
			if(!r.length){
				for(key in obj) r.push(key + '');
			}
		}
		return r;
	};

	/**
	 * オブジェクト自身の全てのプロパティ名を配列で返します。  
	 * ArrayやArrayLike Objectの場合はその要素の添字も含みます  
	 * 組込みオブジェクトの定義済みのプロパティやプロトタイプチェインのプロパティは除きます。
	 * @param {*} obj オブジェクト
	 * @return {Array<string>}
	 */
	Utils.objectKeys = function(obj){
		var keys, key, o, ignoreKeys, hasConstructor,
			r = [],
			type = typeof obj,
			name = nameOf(obj);
		if(type != 'object'){
			if(type == 'string'){
				for(var i = 0; i < obj.length; i++) r.push(i + '');
			}
			return r;
		}
		if(name == 'Prototype'){
			for(key in obj) r.push(key);
			return r;
		}
		o = (hasConstructor = typeof obj.constructor == 'function') || name == 'Object' ? {} :
		    name == 'Mail'? null :
		    name == 'StringList' ? Strings :
		    name.indexOf('VCL') == 0 || (name == 'CoolBar' && (name = 'VCLCoolBar')) ? eval('(function(){try{return new ' + name + ';}catch(e){return null;}})()') :
		    Utils.getObject(name, null, null);
		keys = isNull(o) ? {}.getKeys() : o.getKeys();
		if(hasConstructor){
			keys.push('constructor');
		}else if(name == 'Ini'){
			keys = keys.concat(['readSection', 'readSections', 'deleteKey', 'write', 'read', 'eraseSection', 'update', 'sectionExists', 'filename']);
		}else if(name == 'RegIni'){
			keys = keys.concat(['readSection', 'readSections', 'deleteKey', 'write', 'read', 'eraseSection', 'sectionExists', 'key', 'rootKey']);
		}else if(name == 'Struct'){
			keys = keys.concat(['clear', 'sizeOf', 'define', 'length']);
		}else if(name == 'RegExp'){
			for(var i = 0; i < keys.length; i++) keys[i] = keys[i][0] == '$' ? "\\" + keys[i] : keys[i];
		}
		ignoreKeys = new RegExp('^(' + keys.join('|') + ')$');
		if(typeof obj.length == 'number'){
			for(key in obj){
				if(typeof key == 'number') r.push(key.toString());
			}
		}
		if(typeof obj.getKeys == 'function'){
			if(r.length) ignoreKeys = new RegExp('^(' + keys.concat(r).join('|') + ')$');
			keys = obj.getKeys();
			for(var i = 0; i < keys.length; i++){
				key = keys[i];
				if(!ignoreKeys.test(key)) r.push(key);
			}
		}
		return r;
	};

	/**
	 * <pre>
	 * 指定した最初のオブジェクトに複数のオブジェクトをマージして返します。
	 * オブジェクトの指定が一つだけの場合はその時のthisに対してマージします
	 * マージ元で循環参照が有った場合はマージ先でも同様の循環構造を再現します
	 * マージ元にオブジェクト以外やString,StringBufferオブジェクトを指定した場合は空オブジェクト{}として扱います
	 * 
	 * Utils.extend([deep,] [same,] [destination,] source1[, source2[, ...]])
	 *  deep: 省略可 trueならば深いコピー(deep copy) デフォルトはfalse
	 *  same: 省略可 trueならば同名のプロパティは同じ型の場合のみ上書き デフォルトはfalse
	 *  destination: 省略可  マージ先 拡張するオブジェクト 省略した場合はthis
	 *  source1,2...: マージ元 オブジェクト
	 * </pre>
	 * @example
	 * 例1: Utils.extend(destination, source); //destinationにsoucreの内容をコピー
	 * 例2: Utils.extend(true, destination, source, source2); //destinationにsoucreとsourc2の内容をディープコピー
	 * 例3: Utils.extend(source); //Utilsにsourceの内容をコピー
	 * 例4: Obj.extend = Utils.extend;
	 *      Obj.extend(source); //Objにsourceの内容をコピー
	 * @function
	 * @param {...*} var_args
	 * @return {*} マージしたオブジェクト
	 */
	Utils.extend = (function(){
		var _extend = function(cache, deep, same, destination, source){
			var dest, src, key, index, ex, destType, srcType, isUndef,
				keys = Utils.keys(source),
				len = keys.length;

			for(var i = 0; i < len; i++){
				key = keys[i];
				if(typeof source[key] == 'undefined' && nameOf(source) == 'IrvineFolderData') continue;
				src = source[key];
				isUndef = typeof destination[key] == 'undefined';
				dest = isUndef ? null : destination[key];
				destType = nameOf(dest) || typeof dest;
				srcType = nameOf(src) || typeof src;
				if(same && !isUndef && destType != srcType) continue;
				if(deep && typeof src == 'object'){
					if((index = cache.indexOf(src)) != -1){
						destination[key] = cache.dest[index];
						continue;
					}
					ex = false;
					switch(srcType){
						case 'Object':
							dest = destType == 'Object' ? dest : {};
							ex = true;
							break;
						case 'Array':
							dest = destType == 'Array' ? dest : [];
							ex = true;
							break;
						case 'Number':
							dest = new Number(src.valueOf());
							break;
						case 'Boolean':
							dest = new Boolean(src.valueOf());
							break;
						case 'RegExp':
							dest = new RegExp();
							for(var j in dest) dest[j] = src[j];
							break;
						case 'Date':
							dest = new Date(src.getTime());
							dest.format = src.format;
							break;
						case 'StringList':
							dest = new Strings(src.text);
							dest.sorted = src.sorted;
							dest.caseSensitive = src.caseSensitive;
							dest.duplicates = src.duplicates;
							break;
						case 'URL':
							dest = new URL(src.url);
							break;
						case 'Cookie':
							dest = new Cookie();
							dest.parse(src.toString());
							break;
						default:
							if(src === String){
								destination[key] = new String(src.toString());
								continue;
							}else if(src === StringBuffer){
								destination[key] = new StringBuffer(src.text);
								continue;
							}else{
								dest = src;
							}
					}
					cache.dest.push(dest);
					cache.src.push(src);
					if(ex) dest = arguments.callee(cache, deep, same, dest, src);//_extend(cache, deep, same, dest, src);
					destination[key] = dest;
				}else{
					destination[key] = src;
				}
			}
			return destination;
		};
		return function(/*[deep,] [same,] [destination,] source1[, source2[, ...]]*/){
			var source,
				destination = arguments[0],
				deep = false,
				same = false,
				index = 1,
				len = arguments.length,
				cache = {
					dest: [],
					src: [],
					indexOf: function(obj){
						var len = this.src.length;
						for(var i = 0; i < len; i++){
							if(this.src[i] === obj || this.dest[i] === obj) return i;
						}
						return -1;
					}
				};

			if(typeof destination == 'boolean'){
				deep = destination;
				destination = arguments[index];
				index++;
				if(typeof destination == 'boolean'){
					same = destination;
					destination = arguments[index];
					index++;
				}
			}
			if(len == index){
				destination = this;
				index--;
			}
			//Stringオブジェクト同士,StringBufferオブジェクト同士の比較は常にtrueとなるバグを利用
			//またこれらはブラケット表記法ではプロパティにアクセスできないので{}とする
			if(typeof destination != 'object' || (destination === String || destination === StringBuffer)){
				destination = {};
			}
			var destType = nameOf(destination);
			for(;index < len; ++index){
				source = arguments[index];
				if(typeof source == 'object' && !(destination === source)){
					if(same && destType != nameOf(source)) continue;
					cache.dest.push(destination);
					cache.src.push(source);
					destination = _extend(cache, deep, same, destination, source);
				}
			}
			return destination;
		};
	})();

	/**
	 * 指定したプロトタイプとプロパティで新しいオブジェクトを生成します
	 * @param {string} ctorName 内部で使用するコンストラクタ関数の名前。
	 *     DMonkeyではprototypeは同名の関数同士で共有されます。 共有を避けたい場合は一意の名前にしてください
	 * @param {Object=} proto 新しいオブジェクトのプロトタイプとなるオブジェクト
	 * @param {Object=} prop このオブジェクトの各プロパティを新しいオブジェクトに追加する
	 * @return {Object}
	 */
	Utils.objCreate = function(ctorName, proto, prop){
		var s = [
			'function ' + ctorName + '(){}',

			'if(typeof proto == "object" || isNull(proto)) ' + ctorName + '.prototype = proto;',

			'var obj = new ' + ctorName + ';',

			'if(typeof prop == "object"){',
			'    var key, keys = Utils.keys(prop);',
			'    for(var i in keys){',
			'        key = keys[i];',
			'        obj[key] = prop[key];',
			'    }',
			'}',

			'return obj;'
		].join("\n");


		return eval('(function(){' + s + '})()');
	};

	/**
	 * <pre>
	 * 他のコンストラクタからプロトタイプを継承します。クラスの継承を擬似的に実現させます。
	 * 親のprototypeに constructor プロパティを追加します。 親自身のコンストラクタ関数です。
	 * 子のprototypeに _super プロパティを追加します。 親のコンストラクタ関数です。
	 * 子のprototypeに _base メソッドを追加します。 親メソッドの呼び出しに使用します。
	 * function _base(selfObj, methodName, var_args)
	 *  selfObj: 呼び出し先でthisとなる値 通常は自身を指定してください
	 *  methodName: 呼び出す親のメソッドの名前
	 *  var_args: 親メソッドに渡す引数
	 * </pre>
	 * @example
	 * function Parent(a){this.a = a;}
	 * function Child(a){
	 *     //親の呼び出し例
	 *     //例1:
	 *         this._base(this, 'constructor', a);
	 *     //例2:
	 *         Utils.call(Parent, this, a);
	 *     //例3:
	 *         Utils.call(Child.prototype._super, this, a);
	 *     //例4(DMonkey固有の仕様):
	 *         var super_ = Child.prototype._super;
	 *         super_(a);
	 *     //例5(DMonkey固有の仕様)
	 *         Parent(a);
	 *     //駄目な例1:
	 *         this._super(a);
	 *     //駄目な例2:
	 *         Child.prototype._super(a);
	 * }
	 * Utils.inherits(Child, Parent);
	 * @function
	 * @param {Function} childCtor 子クラスとなるコンストラクタ関数
	 * @param {Function} parentCtor 親クラスとなるコンストラクタ関数
	 */
	Utils.inherits = (function(){
		var c = {count: 0};//DMonkeyではオブジェクトでないと正しくクロージャを扱えない
		return function(childCtor, parentCtor) {
			//DMonkeyでは同じ名前の関数でprototypeが共有されるため毎回違う名前を使用する
			var tempCtorName = '_inherits_tempCtor_' + c.count++;
    	
			childCtor.prototype = Utils.objCreate(tempCtorName, parentCtor.prototype);
			childCtor.prototype._super = parentCtor;
			childCtor.prototype.constructor = childCtor;
    	
			parentCtor.prototype.constructor = parentCtor;
    	
			//動的差し替え
			childCtor.prototype._base = (function(parent){
				return function(selfObj, methodName, var_args){
					if(typeof parent._super == 'function'){
						var pre_base = this._base;
						this._base = parent._base;
						try{
							var r = Utils.apply(parent[methodName], selfObj, arguments.slice(2)); //DMonkeyではargumentsはただの配列(.calleが追加されている)
						}finally{
							this._base = pre_base;
						}
					}else{
						var r = Utils.apply(parent[methodName], selfObj, arguments.slice(2));
					}
					return r;
				};
			})(parentCtor.prototype);
		};
	})();

	/**
	 * destオブジェクトにsrcオブジェクトの全てのメンバーをコピーします
	 * @param {Object} dest
	 * @param {Object} src
	 */
	Utils.mixin = function(dest, src){
		if(typeof dest == 'object'){
			var key,
				keys = Utils.keys(src),
				len = keys.length;
			for(var i = 0; i < len; i++){
				key = keys[i];
				dest[key] = src[key];
			}
		}
		return dest;
	};

	/**
	 * thisや引数が束縛された新たな関数を生成して返します
	 * @param {Function} fn 対象とする関数
	 * @param {Object} selfObj 関数内でthisとして使用される値
	 * @param {...*} var_args 関数に渡される引数。 生成された関数を呼び出す時に指定された引数はこれらの後の引数として使用されます。
	 * @return {Function}
	 */
	Utils.bind = function(fn, selfObj, var_args){
		return (function(fn, selfObj, args){
			return function(){
				return Utils.apply(fn, selfObj, args.concat(arguments));
			};
		})(fn, selfObj, arguments.slice(2));
	};

	/**
	 * iniファイルから設定値を読み込みオブジェクトで返します  
	 * 各設定値は適切なプリミティブ値に変換されます  
	 * pathはiniファイルのパス又はIniオブジェクトを渡してください  
	 * Iniオブジェクトを渡した場合はそこから設定値を読み込みます  
	 * defを指定した場合は取得したオプションとdefをマージした新しいオブジェクトを返します
	 * @param {Object} [def] デフォルト値
	 * @param {string|Ini} [path=Dorothy.userIniPath] iniファイルのパス又はIniオブジェクト
	 * @return {Object}
	 */
	Utils.loadIni = function(def, path){
		var sec, key, keys,
			ini = nameOf(path) == 'Ini' ? path : new Ini(path && Utils.expandPath(path) || Utils.getUserIniPath()),
			obj = {},
			secs = ini.readSections();
		for(var i in secs){
			sec = secs[i];
			obj[sec] = {};
			keys = ini.readSection(sec);
			for(var j in keys){
				key = keys[j];
				obj[sec][key] = Utils.strToPrimitive(ini.read(sec, key, ""));
			}
		}
		return typeof def == 'object' ? Utils.extend(true, true, {}, def, obj) : obj;
	};

	/**
	 * iniファイルに設定値を保存します  
	 * dataオブジェクトに存在しないセクションやキーは削除されます  
	 * pathはiniファイルのパス又はIniオブジェクトを渡してください  
	 * Iniオブジェクトを渡した場合はそこに設定値を保存します。 Iniオブジェクトの内容は更新されます  
	 * @param {Object} data iniファイルに保存する設定値を持つオブジェクト
	 * @param {string|Ini} [path=Dorothy.userIniPath] iniファイルのパス又はIniオブジェクト
	 */
	Utils.saveIni = function(data, path){
		if(typeof data != 'object') return;
		var v,
			ini = nameOf(path) == 'Ini' ? path : new Ini(path && Utils.expandPath(path) || Utils.getUserIniPath()),
			dir = new Directory(Utils.extractPath(ini.filename)),
			secs = ini.readSections();
		for(var i in secs){
			ini.eraseSection(secs[i]);
		}

		for(var sec in data){
			if(typeof data[sec] == 'object'){
				for(var key in data[sec]){
					v = data[sec][key];
					if(isUndefined(v)) continue;
					ini.write(sec, key, v);
				}
			}
		}
		if(!dir.exists()) dir.make();
		println('save ini: ' + ini.filename);
		ini.update();
	};

	/**
	 * iniファイルまたはJSONファイルから設定値を読み込みます
	 * @param {Object} [def] デフォルト値
	 * @param {string|Ini} [path=Dorothy.userIniPath] iniファイルのパス又はIniオブジェクト、又はJSONファイルのパス
	 * @param {...*} var_args JSONファイルの場合にJSON.loadに渡す引数
	 * @return {Object}
	 */
	Utils.loadOption = function(def, path, var_args){
		if(/\.json$/.test(path)){
			common_load('json');
			if(path.slice(-4) == '.json') path = Dorothy.matchFile + path;
			if(!/^[a-z]:/i.test(path)) path = Utils.getUserPath() + path.replace('^\s*\\', '');
			var obj = Utils.apply(JSON.load, JSON, [path].concat(arguments.slice(2))) || {};
			return typeof def == 'object' ? Utils.extend(true, true, {}, def, obj) : obj;
		}else{
			return Utils.loadIni(def, path);
		}
	};

	/**
	 * iniファイルまたはJSONファイルに設定値を保存します  
	 * pathはJSONファイルのパス又はiniファイルのパス又はIniオブジェクトを渡してください  
	 * Iniオブジェクトを渡した場合はそこに設定値を保存します。 Iniオブジェクトの内容は更新されます  
	 * @param {Object} data ファイルに保存する設定値を持つオブジェクト
	 * @param {string|Ini} [path=Dorothy.userIniPath] JSONファイルのパス又はiniファイルのパス又はIniオブジェクト
	 * @param {...*} var_args JSONファイルの場合にJSON.saveに渡す引数
	 */
	Utils.saveOption = function(data, path, var_args){
		if(/\.json$/.test(path)){
			common_load('json');
			if(path.slice(-4) == '.json') path = Dorothy.matchFile + path;
			if(!/^[a-z]:/i.test(path)) path = Utils.getUserPath() + path.replace('^\s*\\', '');
			Utils.apply(JSON.save, JSON, [path, data].concat(arguments.slice(2)));
		}else{
			Utils.saveIni(data, path);
		}
	};

	/**
	 * 日時を表す文字列をIrvineで使用されているTDateTimeの数値に変換します
	 * @param {string} str 「yyyy/mm/dd hh:nn:ss」または「hh:nn:ss」形式の文字列
	 * @return {number} TDateTimeの数値
	 */
	Utils.strToDateTime = function(str){
		var d = new Date(),
			oneday = 86400000, //一日
			unixDateDelta = 25569, //UnixDateDelta[UNIX時間とTDateTimeとの差]
			offset = d.getTimezoneOffset() * 60 * 1000; //世界協定時刻(UTC)との差
		if(/^((\d{4})\/(\d+)\/(\d+))?\s*((\d+):(\d+):(\d+))?$/.test(str)){
			if(RegExp.$1){
				d.setYear(RegExp.$2);
				d.setMonth(RegExp.$3 - 1);
				d.setDate(RegExp.$4);
			}
			d.setHours(RegExp.$6);
			d.setMinutes(RegExp.$7);
			d.setSeconds(RegExp.$8);
			d.setMilliseconds(0);

			return (d.getTime() - offset + unixDateDelta * oneday) / oneday;
			//return (d.getTime() - offset) / oneday + UnixDateDelta;
		};
		return 0;
	};

	/**
	 * Irvineで使用されているTDateTimeの数値を日時を表す文字列に変換します
	 * @param {number} n TDateTimeの数値
	 * @param {string=} formatStr Dateオブジェクトによる文字列変換時の書式
	 * @return {string} 日時を表す文字列
	 */
	Utils.dateTimeToStr = function(n, formatStr){
		var d = new Date();
		if(formatStr) d.format = formatStr;
		d.setTime((n - 25569) * 86400000 + (d.getTimezoneOffset() * 60 * 1000)); // (datatime - UnixDateDelta[UNIX時間-TDateTime]) * 一日 + 世界協定時刻(UTC)との差
		return d.toString();
	};

	/**
	 * folderdataが存在しない場合にfolderdataを定義します
	 */
	Utils.setFolderData = function(){
		if(typeof folderdata == 'object' && nameOf(folderdata) == 'IrvineFolderData') return;

		if(!Utils.queueFolder) throw Utils.showError('Utils.queueFolderが空', 'Utils.dms', '.setFolderData');

		var folder;
		var nowTime = Utils.strToDateTime(new Date().toString());

		folderdata = new IrvineFolderData;

		try{
			folder = new ActiveXObject('Irvine.Folder');
			folder.path = Utils.queueFolder;
		}catch(e){
			var v = {};
			for(var key in folderdata){
				if(typeof folderdata[key] != 'undefined') v[key.toLowerCase()] = '';
			}
			v['tryconenctcount'] = '';

			var path = new Directory( (new irvinePath).queue + Utils.queueFolder ).path;
			var ini = new Ini(path + 'queue.ini');
			var key, keys, sec, secs = ini.readSections();
			for(var i in secs){
				sec = secs[i];
				keys = ini.readSection(sec);
				for(var j in keys){
					key = keys[j];
					v[key] = ini.read(sec, key, '');
				}
			}
			folder = {Values: v};
		}

		//型変換はfolderdata側がやってくれる
		//folderdata.AbsolutePath        = folder.AbsolutePath;
		folderdata.Agent               = folder.Values['agent'];
		folderdata.AutoRemoveFolder    = folder.Values['autoremovefolder'] ;
		folderdata.AutoRename          = folder.Values['autorename'] ;
		folderdata.AutoRenameDate      = folder.Values['autorenamedate'] ;
		folderdata.AutoRenameHash      = folder.Values['autorenamehash'] ;
		folderdata.AutoRenameHashNum   = folder.Values['autorenamehashnum'] ;
		folderdata.AutoSort            = folder.Values['autosort'] ;
		folderdata.AutoStart           = folder.Values['autostart'] ;
		folderdata.BeginAutoStart      = folder.Values['beginautostart'] ;
		folderdata.BeginTime           = Utils.strToDateTime(folder.Values['begintime']);
		if(folderdata.BeginTime < nowTime) folderdata.BeginTime += 1;
		folderdata.BufferSize          = folder.Values['buffersize'];
		folderdata.CernType            = folder.Values['cerntype'] ;
		folderdata.ChangeImportFolder  = folder.Values['changeimportfolder'] ;
		folderdata.CharCode            = folder.Values['charcode'] ;
		folderdata.ClearTrash          = folder.Values['cleartrash'] ;
		folderdata.Cookie              = folder.Values['cookie'] ;
		folderdata.CookieStr           = folder.Values['cookiestr'];
		folderdata.CrcTryCount         = folder.Values['crctrycount'];
		folderdata.CreateDate          = Utils.strToDateTime(folder.Values['createdate']);
		folderdata.DateFolder          = folder.Values['datefolder'] ;
		folderdata.DownloadCount       = folder.Values['downloadcount'];
		folderdata.DupFile             = folder.Values['dupfile'] ;
		folderdata.DupFileConfirm      = folder.Values['dupfileconfirm'] ;
		folderdata.DupUrl              = folder.Values['dupurl'] ;
		folderdata.DupUrlConfirm       = folder.Values['dupurlconfirm'] ;
		folderdata.EndTime             = Utils.strToDateTime(folder.Values['endtime']);
		if(folderdata.EndTime < nowTime) folderdata.EndTime += 1;
		folderdata.Expanded            = folder.Values['expanded'] ;
		folderdata.Folder              = folder.Values['folder'];
		folderdata.FtpDirSearch        = folder.Values['ftpdirsearch'] ;
		folderdata.FtpProxy            = folder.Values['ftpproxy'];
		folderdata.FtpProxyPassword    = folder.Values['ftpproxypassword'];
		folderdata.FtpProxyUserId      = folder.Values['ftpproxyuserid'];
		folderdata.FtpSubDirSearch     = folder.Values['ftpsubdirsearch'] ;
		folderdata.FtpTimeout          = folder.Values['ftptimeout'];
		folderdata.GetDate             = folder.Values['getdate'] ;
		folderdata.HiddenAttr          = folder.Values['hiddenattr'] ;
		folderdata.History             = folder.Values['history'] ;
		folderdata.HttpMethod          = folder.Values['httpmethod'] ;
		folderdata.HttpProxy           = folder.Values['httpproxy'];
		folderdata.HttpProxyPassword   = folder.Values['httpproxypassword'];
		folderdata.HttpProxyUserId     = folder.Values['httpproxyuserid'];
		folderdata.HttpTimeout         = folder.Values['httptimeout'];
		folderdata.HttpVersion         = folder.Values['httpversion'] ;
		folderdata.Ignore3xx           = folder.Values['ignore3xx'] ;
		folderdata.Ignore404           = folder.Values['ignore404'] ;
		folderdata.Image               = folder.Values['image'];
		folderdata.InvalidSplitDownload= folder.Values['invalidsplitdownload'] ;
		folderdata.LessSize            = folder.Values['lesssize'];
		folderdata.LessSpeed           = folder.Values['lessspeed'];
		folderdata.LessSpeedRetry      = folder.Values['lessspeedretry'] ;
		folderdata.LimitSpeed          = folder.Values['limitspeed'] ;
		folderdata.ListViewStyle       = folder.Values['listviewstyle'] ;
		folderdata.MailAddress         = folder.Values['mailaddress'];
		folderdata.Mark                = folder.Values['mark'] ;
		folderdata.MaxItemCount        = folder.Values['maxitemcount'];
		folderdata.MaxSpeed            = folder.Values['maxspeed'];
		folderdata.MoreSize            = folder.Values['moresize'];
		folderdata.MoveTrash           = folder.Values['movetrash'] ;
		folderdata.Nlst                = folder.Values['nlst'] ;
		folderdata.NoCache             = folder.Values['nocache'] ;
		folderdata.Pasv                = folder.Values['pasv'] ;
		//folderdata.Path                = folder.Path;
		folderdata.Post                = folder.Values['post'];
		folderdata.Postpone            = folder.Values['postpone'];
		folderdata.Priority            = folder.Values['priority'];
		folderdata.ProxyErrorCount     = folder.Values['proxyerrorcount'];
		folderdata.ProxyErrorTo        = folder.Values['proxyerrorto'] ;
		folderdata.RandomAgent         = folder.Values['randomagent'] ;
		folderdata.RandomFtpProxy      = folder.Values['randomftpproxy'] ;
		folderdata.RandomHttpProxy     = folder.Values['randomhttpproxy'] ;
		folderdata.Referer             = folder.Values['referer'] ;
		folderdata.RefererStr          = folder.Values['refererstr'];
		folderdata.RemoveCrcError      = folder.Values['removecrcerror'] ;
		folderdata.RemoveQuery         = folder.Values['removequery'] ;
		folderdata.RemoveTrashItem     = folder.Values['removetrashitem'] ;
		folderdata.ResumeOverwrite     = folder.Values['resumeoverwrite'] ;
		folderdata.RollBackBytes       = folder.Values['rollbackbytes'];
		folderdata.SelectIndex         = folder.Values['selectindex'];
		folderdata.SortItem            = folder.Values['sortitem'] ;
		folderdata.SplitCount          = folder.Values['splitcount'];
		folderdata.StorageTrashCount   = folder.Values['storagetrashcount'];
		folderdata.TryConnect          = folder.Values['tryconnect'] ;
		folderdata.TryConnectCount     = folder.Values['tryconenctcount'];//iniの方は元から綴りが間違っている
		folderdata.TryConnectWait      = folder.Values['tryconnectwait'];
		folderdata.TryResume           = folder.Values['tryresume'] ;
		folderdata.UrlEncode           = folder.Values['urlencode'] ;
		folderdata.UrlFolder           = folder.Values['urlfolder'] ;
		folderdata.UrlUtf8             = folder.Values['urlutf8'] ;
		folderdata.UseBeginTime        = folder.Values['usebegintime'] ;
		folderdata.UseCrc              = folder.Values['usecrc'] ;
		folderdata.UseEndTime          = folder.Values['useendtime'] ;
		folderdata.UseFtpProxy         = folder.Values['useftpproxy'] ;
		folderdata.UseHttpProxy        = folder.Values['usehttpproxy'] ;
		folderdata.UseHttpProxyForFtp  = folder.Values['usehttpproxyforftp'] ;
		folderdata.UseHttpProxyForHttps= folder.Values['usehttpproxyforhttps'] ;
		folderdata.UseLessSize         = folder.Values['uselesssize'] ;
		folderdata.UseMoreSize         = folder.Values['usemoresize'] ;
		folderdata.UseRecycle          = folder.Values['userecycle'] ;
		folderdata.UseResume           = folder.Values['useresume'] ;
		folderdata.UseRollBack         = folder.Values['userollback'] ;
		folderdata.ViewIndex           = folder.Values['viewindex'];
	};

	/**
	 * 指定したスクリプトのバージョンを取得します  
	 * IrvineとDorothy2のスクリプトに対応しています
	 * @function
	 * @param {string} path スクリプトのフルパス
	 * @return {string|number} スクリプトのバージョン 数値に変換可能な場合は数値それ以外は文字列
	 */
	Utils.getScriptVersion = (function(){
		var cache = {};
		return function(path){
			if(cache.hasKey(path)) return cache[path];
			var head,
				sl = new Strings(),
				version = null;
			try{
				sl.loadFromFile(path);
				if(/^\/\*(.+?)\*\//.test(sl.text) ||
				   /^\/\/Dorothy2(.+?)^\/\/end/m.test(sl.text)){
					head = RegExp.$1;
					if(/^(\/\/)?version=([^\n]+)/m.test(head)){
						version = RegExp.$2;
						if(isFinite(version)) version = parseFloat(version);
					}
				}
			}catch(e){
				println(e);
			}
			cache[path] = version;
			return version;
		};
	})();

	/**
	 * 実行環境別に適切なアイテムの保存先のパスを取得します  
	 * 相対パスだった場合は絶対パスになるまで順に上位キューフォルダの保存パスと連結させていきます
	 * @return {string}
	 */
	Utils.getSavePath = function(){
		if(Utils.isDorothy2set){
			return Dorothy.userPath;
		}
		var ipath = typeof item != 'undefined' ? item.folder : '';
		if(/^[a-z]:/i.test(ipath)){
			ipath += "\\";//C: -> C:\  \が二重になっても問題ない
			return new Directory(ipath).path;
		}


		//絶対パスになるまで順に上位キューフォルダから保存パスを取得
		var path;
		if(Utils.isDOA && (typeof folderdata.Folder == 'undefined' || !folderdata.Folder)){
			var folder = new ActiveXObject('Irvine.Folder');
			folder.path = Utils.queueFolder;
			path = folder.Data('queue', 'folder') + "\\" + ipath;
			while(!/^[a-z]:/i.test(path) && folder.path != '/'){
				folder = folder.Parent;
				path = folder.Data('queue', 'folder') + "\\" + path;
			}
		}else{
			path = folderdata.Folder + "\\" + ipath;
			var qPath = (new irvinePath).queue;
			var irvQPath = Utils.queueFolder;
			var ini;
			while(!/^[a-z]:/i.test(path)){
				irvQPath = irvQPath.slice(0, irvQPath.lastIndexOf('/'));
				ini = new Ini(new Directory(qPath + irvQPath).path + 'queue.ini');
				path = ini.read('queue', 'folder', '') + "\\" + path;
				if(!irvQPath) break;
			}
		}
		return new Directory(path).path;
	};

	/**
	 * pathを実行環境別に適切な保存先の絶対パスに変換します  
	 * 既に絶対パスだった場合は何もしません  
	 * ただし 'C:\aaa\..\bbb\' のような指定の場合は "C:\bbb\' に変換されます  
	 * baseを指定した場合はbaseを基準パスとして使用します  
	 * 単純に連結させているだけなので基準パスにファイル名を含ませないで下さい
	 * @param {string} [path=''] 変換するパス
	 * @param {string} [base=''] 基準パス
	 * @return {string}
	 */
	Utils.expandPath = function(path, base){
		path = Utils.toStr(path || '');
		base = base || '';
		if(!/^[a-z]:\\/i.test(path)){
			if(!base || !/^[a-z]:\\/i.test( (path = Utils.toStr(base) + "\\" + path) )){
				path = Utils.getSavePath() + path;
			}
		}
		var i = path.lastIndexOf("\\");
		var folder = path.slice(0, i + 1);
		var file = path.slice(i + 1);
		return new Directory(folder).path + file;
	};

//======================================Dorothy=======================================================
	/**
	 * 実行環境がDorothy2Aならばtrue
	 * @type {boolean}
	 */
	Utils.isDorothy2A = false;

	/**
	 * 実行環境がDorothy2setならばtrue
	 * @type {boolean}
	 */
	Utils.isDorothy2set = false;

	/**
	 * 実行環境がOnListMenuClickのDorothy2set(「Dorothy2サイト設定」)ならばtrue
	 * @type {boolean}
	 */
	Utils.isDorothy2ListMenu = false;

	/**
	 * 実行環境がDOAならばtrue
	 * @type {boolean}
	 */
	Utils.isDOA = false;

	/**
	 * 実行環境がDorothy2Rならばtrue
	 * @type {boolean}
	 */
	Utils.isRentan = typeof Dorothy.rVersion != 'undefined';

	/**
	 * folderdata.Postのコメントオプションから取得したキューフォルダのパス
	 * @type {string}
	 */
	Utils.queueFolder = '';

	(function(){
		switch(WScript.ScriptName){
			case 'Dorothy2A.dms':
			case 'Dorothy2R_a.dms':
				Utils.isDorothy2A = true;
				Utils.queueFolder = /queue\s*=\s*(\/[^;]+)/g.test(folderdata.Post) ? RegExp.$1 : '';
				break;
			case 'Dorothy2R_listmenu.dms':
			case 'Dorothy2ListMenu.dms':
				Utils.isDorothy2ListMenu = true;
				//next
			case 'Dorothy2set.dms':
			case 'Dorothy2R_set.dms':
				Utils.isDorothy2set = true;
				Utils.queueFolder = Irvine.Current.Path;
				break;
			case 'DOA.dms':
			case 'xor100813_2.dms':
			case 'Dorothy2R_doa_list.dms':
			case 'Dorothy2R_doa_tree.dms':
				Utils.isDOA = true;
				Utils.queueFolder = DOA.CurrentQueueFolder;
				break;
			default:
				throw Utils.showError('不明な実行環境: ' + WScript.ScriptName, 'Utils.dms', 'WScript.ScriptName');
		}
	})();

	/**
	 * 現在のアイテムのIrvineのキューフォルダのパスを取得します
	 * @return {string}
	 */
	Utils.getQueueFolderPath = function(){
		var q;
		if(Utils.isDorothy2A){
			q = /queue\s*=\s*(\/[^;]+)/g.test(folderdata.Post) ? RegExp.$1 : '';
		}else if(Utils.isDorothy2set){
			q = Irvine.Current.Path;
		}else if(Utils.isDOA){
			q = DOA.CurrentQueueFolder;
		}
		return q;
	};

	/**
	 * Dorothy.userPathを取得します Dorothy.userPathが使えないDOA用
	 * @return {string}
	 */
	Utils.getUserPath = function(){
		return typeof Dorothy.userPath != 'undefined' ? Dorothy.userPath : Dorothy.path + "user\\" + Dorothy.matchFile + "\\";
	};

	/**
	 * Dorothy.userIniPathを取得します Dorothy.userIniPathが使えないDOA用
	 * @return {string}
	 */
	Utils.getUserIniPath = function(){
		return typeof Dorothy.userIniPath != 'undefined' ? Dorothy.userIniPath : Utils.getUserPath() + Dorothy.matchFile + '.ini';
	};

	/**
	 * Dorothy2A.dmsのバージョンを取得します Dorothy2Rの場合はDorothy.rVersionの値を返します
	 * @return {number}
	 */
	Utils.getVersionDorothy2A = function(){
		return Utils.isRentan ? Dorothy.rVersion : (Utils.isDorothy2A ? parseFloat(Dorothy.version) : Utils.getScriptVersion((new irvinePath).scripts + 'Dorothy2A.dms'));
	};

	/**
	 * Dorothy2set.dmsのバージョンを取得します Dorothy2Rの場合はDorothy.rVersionの値を返します
	 * @return {number}
	 */
	Utils.getVersionDorothy2set = function(){
		return Utils.isRentan ? Dorothy.rVersion : Utils.getScriptVersion((new irvinePath).scripts + 'Dorothy2set.dms');
	};

	/**
	 * Dorothy2ListMenu.dmsのバージョンを取得します Dorothy2Rの場合はDorothy.rVersionの値を返します
	 * @return {number}
	 */
	Utils.getVersionDorothy2ListMenu = function(){
		return Utils.isRentan ? Dorothy.rVersion : Utils.getScriptVersion((new irvinePath).scripts + 'Dorothy2ListMenu.dms');
	};

	/**
	 * DOA.dmsのバージョンを取得します Dorothy2Rの場合はDorothy.rVersionの値を返します
	 * @return {number}
	 */
	Utils.getVersionDOA = function(){
		return Utils.isRentan ? Dorothy.rVersion : Utils.getScriptVersion((new irvinePath).scripts + 'DOA.dms');
	};

	/**
	 * <pre>
	 * DOAスクリプト用
	 * DOA.statusをDOA_ITにし、itemのプロパティに適切にDOAの各値を設定します
	 *  DOA.nameが空ではないのなら    item.filename = DOA.name
	 *  DOA.commentが空ではないのなら item.comment += DOA.comment
	 *  DOA.sizeが123.4MB 等の形式の文字列(/^([\d\.]+)([KMG])?(B|Byte)?$/i)ならば
	 *   バイト値に変換して item.filesize に設定します
	 * </pre>
	 */
	Utils.setDOA_IT = function(){
		if(!Utils.isDOA) throw Utils.showError('.setDOA_IT()は DOA でしか使用できません', 'Utils.dms', '.setDOA_IT');

		if(typeof DOA_IT != 'number' || typeof item != 'object' || nameOf(item) != 'IrvineItem'){
			throw Utils.showError('未知のエラー。DOA_ITまたはitemが正しく定義されていません', 'Utils.dms', '.setDOA_IT');
		}

		DOA.status = DOA_IT;
		if(DOA.name) item.filename = DOA.name;
		if(DOA.comment) item.comment += DOA.comment;
		if(!item.url) item.url = urlinfo.url;

		var size = DOA.size.replace(/[,\s]+/g, '');
		if(/^([\d\.]+)([KMG])?(B|Byte)?$/i.test(size)){
			switch(RegExp.$2.toUpperCase()){
				case '':
					item.filesize = RegExp.$1 * 1;
					break;
				case 'K':
					item.filesize = RegExp.$1 * 1024;
					break;
				case 'M':
					item.filesize = RegExp.$1 * 1048576;
					break;
				case 'G':
					item.filesize = RegExp.$1 * 1073741824;
					break;
			}
		}
		return true;
	};

	/** DOAにて不足している各変数やプロパティを設定します DOAスクリプトのmain関数内で毎回呼び出してください
	 * @param {IrvineItem} itemData main関数内でのitemData
	 */
	Utils.setDOA = function(itemData){
		if(!Utils.isDOA){
			throw Utils.showError('.setDOA()は DOA でしか使用できません', 'Utils.dms', '.setDOA');
		}else if(typeof itemData != 'object' || nameOf(itemData) != 'IrvineItem'){
			throw Utils.showError('未知のエラー。itemDataが正しく指定されていません', 'Utils.dms', '.setDOA');
		}
		Dorothy.userPath = Utils.getUserPath();
		Dorothy.userIniPath = Utils.getUserIniPath();
		item = itemData;//Global.item とはしない様にする事

		headers = {
			"Referer": "",
			"User-Agent": Irvine.FolderData('http' ,'agent'),
			"Cookie": "",
			"Host": new URL(item.url).host
		};

		if(nameOf(urlinfo) != 'IrvineUrlInfo'){
			urlinfo = Utils.extend(new IrvineUrlInfo, urlinfo);
		}
	};

	/** DOA画面にアイテムを追加します
	 * @param {string} url アイテムのURL
	 * @param {string} [filename=''] アイテムのファイル名
	 * @param {string|number} [filesize=''] アイテムのファイルサイズ
	 * @param {string} [comment=''] アイテムのコメント
	 */
	Utils.doaItemAdd = function(url, filename, filesize, comment){
		if(!Utils.isDOA) throw Utils.showError('.doaItemAdd()は DOA でしか使用できません', 'Utils.dms', '.doaItemAdd');
		filename = filename || '';
		comment = comment || '';
		filesize = filesize || '';
		var listItem = frmDOA.ListView1.Items.add();
		listItem.Caption = url;
		listItem.url = url;
		listItem.irvItem = -1;
		listItem.doa_status = '';
		listItem.doa_link = '';
		listItem.doa_name = filename;
		listItem.SubItems.add('');
		listItem.SubItems.add(filesize);
		listItem.SubItems.add(joint(' / ', filename, comment));
		DOA.urls.add(url);
		DOA.itemsIndex.add(-1);
	};

	/** DOA画面にアイテムを追加します 追加したアイテムのDOA.statusはDOA_ITになります
	 * @param {object|IrvineItem} itemData IrvineItemオブジェクトまたはそれと同じ名前のプロパティをもつオブジェクト
	 */
	Utils.doaItemAdd_IT = function(itemData){
		if(!Utils.isDOA) throw Utils.showError('.doaItemAdd_IT()は DOA でしか使用できません', 'Utils.dms', '.doaItemAdd_IT');
		var url, filename, filesize, comment,
			listItem = frmDOA.ListView1.Items.add();

		if(nameOf(itemData) == 'IrvineItem'){
			listItem.itemData = itemData;
		}else if(typeof itemData == 'object'){
			listItem.itemData = new IrvineItem();
			for(var key in itemData){
				if(listItem.itemData.hasKey(key)){
					listItem.itemData[key] = itemData[key];
				}
			}
		}else{
			listItem.itemData = new IrvineItem();
		}
		url = listItem.itemData.url;
		filename = listItem.itemData.filename || '';
		filesize = listItem.itemData.filesize || '';
		comment = listItem.itemData.comment || '';
		listItem.Caption = url;
		listItem.url = url;
		listItem.irvItem = -1;
		listItem.doa_status = DOA_IT;
		listItem.doa_link = '';
		listItem.doa_name = filename;
		listItem.SubItems.add(DOA_MSG[DOA_IT]);
		listItem.SubItems.add(filesize);
		listItem.SubItems.add(joint(' / ', filename, comment));
		DOA.urls.add(url);
		DOA.itemsIndex.add(-1);
	};


	(function(){
		var loadOption = (function(){
			var cache = {
				loaded: false,
				folderPost: null,
				itemComment: null,
				opt: {}
			};
			var parse = function(s, o){
				s.replace(/\s*([^=;]+?)\s*=([^;]*);?/g, function(a, name, value){
					o[name] = Utils.strToPrimitive(value);
				});
			};

			return function(){
				if(typeof folderdata.Post == 'undefined' || typeof item.comment == 'undefined'){
					Utils.showError('folderdata.Postまたはitem.commentが正しく定義されていません', 'Utils.dms', 'loadOption');
				}
				if(!cache.loaded || cache.folderPost != folderdata.Post || cache.itemComment != item.comment){
					var opt = {};
					parse(folderdata.Post, opt);
					parse(item.comment, opt);
					cache.loaded = true;
					cache.folderPost = folderdata.Post;
					cache.itemComment = item.comment;
					cache.opt = opt;
				}
				return cache.opt;
			};
		})();
		/**
		 * folderdata.Postとitem.commentに設定されたオプションから指定された名前のオプションを取得します  
		 * オプションの各値は適切なプリミティブ値に変換されます
		 * @function
		 * @template T
		 * @param {string} key オプションの名前
		 * @param {T=} def 指定されたオプションが存在しなかった場合に返す値
		 * @return {string|number|boolean|null|undefined|T}
		 */
		Utils.getCommentOption = (function(loadOption){
			return function(key, def){
				var opt = loadOption();
				return opt.hasKey(key) ? opt[key] : def;
			};
		})(loadOption);

		/**
		 * folderdata.Postとitem.commentに設定された全てのオプションを取得します  
		 * オプションの各値は適切なプリミティブ値に変換されます  
		 * defを指定した場合は取得したオプションとdefをマージした新しいオブジェクトを返します
		 * @function
		 * @param {Object=} def デフォルト値
		 * @return {Object}
		 */
		Utils.getCommentOptions = (function(loadOption){
			return function(def){
				var opt = loadOption();
				return typeof def == 'object' ? Utils.extend(true, {}, def, opt) : Utils.extend({}, opt);
			};
		})(loadOption);

	})();

	/**
	 * item.commentにkey=value;形式のオプションを設定します  
	 * 同名のオプションが既に設定されている場合は指定された値で上書きします
	 * @param {string} key オプションの名前
	 * @param {*} value オプションの値
	 */
	Utils.setCommentOption = function(key, value){
		if(typeof item.comment == 'undefined'){
			return Utils.showError('item.commentが正しく定義されていません', 'Utils.dms', '.setCommentOption');
		}
		value = Utils.toStr(value);
		var isMatch = false;
		item.comment = item.comment.replace(/(\s*([^;=]+)\s*=\s*)[^;]*;?/g, function(a, l, name){
			if(name == key){
				isMatch = true;
				return l + value + ';';
			}else{
				return a;
			}
		});
		if(!isMatch) item.comment += (item.comment && !/;\s*$/.test(item.comment) ? ';' : '') + key + '=' + value + ';';
	};


	/** 
	 * 環境別の差異がなるべく少なくなる様にDorothyの関数等を再定義します  
	 * DOAやDorothy2AやDorothy2set等の環境別に存在したりしなかったりするプロパティや関数等を  
	 * なるべく全ての環境で使用できるようにします
	 */
	Utils.redefineDorothy = function(){
		if(Utils.isRentan){
			Global.common_reload = function(){
				for (var i = 0; i < arguments.length; i++) {
					common_xload (arguments [i]);
				}
			};
		}
		if(Utils.isDorothy2A){
			if(Utils.isRentan){
				Global.reset = function(){
					for(var i = 0 ; i < arguments.length ; i++){
						println(arguments[i]);
					}
					var url = new URL(Dorothy.oldUrl);
					urlinfo.url = url.url;
					headers.host = url.host;
				};

			}
			dorothy2_path                = Dorothy.path;
			dorothy2_temp                = dorothy2_path + "temp\\";
			dorothy2_document            = dorothy2_path + "document\\";
			dorothy2_common              = dorothy2_path + "common\\";
			dorothy2_program             = dorothy2_path + "program\\";
			dorothy2_setting             = dorothy2_path + "setting\\";
			dorothy2_system              = dorothy2_path + "system\\";
			dorothy2_project             = dorothy2_path + "project\\";
			dorothy2_projectdata         = dorothy2_path + "projectdata\\";
			dorothy2_bin                 = dorothy2_path + "bin\\";
			dorothy2_user                = dorothy2_path + "user\\";
			dorothy2_system_menu         = dorothy2_system + "menu\\";
			dorothy2_system_menu_new     = dorothy2_system_menu + "new\\";
			dorothy2_system_menu_setting = dorothy2_system_menu + "setting\\";
			dorothy2_system_menu_edit    = dorothy2_system_menu + "edit\\";
			dorothy2_system_menu_project = dorothy2_system_menu + "project\\";
			dorothy2_system_menu_tool    = dorothy2_system_menu + "tool\\";
			dorothy2_system_menu_set     = dorothy2_system_menu + "set\\";
			dorothy2_system_menu_package = dorothy2_system_menu + "package\\";
			dorothy2_system_menu_help    = dorothy2_system_menu + "help\\";
			dorothy2_system_ini          = dorothy2_system + "ini\\";
			irvine_script_path           = (new irvinePath).scripts;
			Dorothy.url = Dorothy.oldUrl;
		}else if(Utils.isDOA){
			if(Utils.isRentan){
				irvine_script_path = (new irvinePath).scripts;
			}else{
				Dorothy.programDir = dorothy2_program;
				Dorothy.version = '' + Utils.getVersionDorothy2A();
				Dorothy.temp = dorothy2_temp;
			}
			var item = new IrvineItem();
			item.url = urlinfo.url;
			Utils.setDOA(new IrvineItem);
		}else if(Utils.isDorothy2set){
			if(!Utils.isRentan){
				Global.print_debug = function(str){
					if(debug) println(str);
				};
			}
			if(!Utils.isDorothy2ListMenu){
				//無理矢理 選択アイテム取得
				item = new IrvineItem;
				var count = Irvine.ItemCount;
				for(var i = 0; i < count; i++){
					if(Irvine.GetItemSelected(i)){
						item.data = Irvine.GetItemData(i);
						if(item.url.indexOf('ttp://') == 0){
							item.url = 'h' + item.url;
						}
						break;
					}
				}
				Dorothy.url = item.url;
			}else{
				if(Utils.isRentan){
					irvine_script_path = (new irvinePath).scripts;
					Dorothy.url = item.url;
				}
			}
			urlinfo = new IrvineUrlInfo;
			urlinfo.url = item.url;
			headers = {
				"Referer": "",
				"User-Agent": Irvine.FolderData('http' ,'agent'),
				"Cookie": "",
				"Host": new URL(item.url).host
			};
		}
		Utils.setFolderData();
	};

	/**
	 * Dorothyの各実行環境で古いバージョンが使用されていないかチェックします  
	 * 古いバージョンが使用されていた場合はエラーメッセージを表示してスクリプトを終了します
	 */
	Utils.checkVersion = function(){
		function err(name, version){
			Utils.showError('古いバージョンの' + name + 'が使用されています。version ' + version + ' 以上を使用してください', 'Utils.dms', '.checkVersion');
			exit();
		}
		var v = {
			a: 0.32,
			doa: 0.26,
			list: 0.44,
			set: 0.20,
			rentan: 20160118
		};
		if(Utils.isRentan){
			if(Dorothy.rVersion < v.rentan){
				err(WScript.ScriptName, v.rentan);
			}
		}else if(Utils.isDorothy2A){
			if(Dorothy.version < v.a){
				err('Dorothy2A.dms', v.a);
			}
		}else if(Utils.isDOA){
			if(Utils.getVersionDOA() < v.doa){
				err('DOA.dms', v.doa);
			}
		}else if(Utils.isDorothy2ListMenu){
			if(Utils.getVersionDorothy2ListMenu() < v.list){
				err('Dorothy2ListMenu.dms', v.list);
			}
		}else if(Utils.isDorothy2set){
			if(Utils.getVersionDorothy2set() < v.set){
				err('Dorothy2set.dms', v.set);
			}
		}
	};

	//このスクリプトは古いバージョンでは一部が正常に機能しないので強制的にバージョンチェックを行います
	Utils.checkVersion();
//====================================================================================================


})();
